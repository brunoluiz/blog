{"data":{"site":{"siteMetadata":{"title":"Bruno Luiz Blog","author":"Bruno Luiz Silva"}},"markdownRemark":{"id":"76a9ce47-f486-5ba3-9bb0-c87ce7caa6d6","excerpt":"GraphQL, REST, gRPC, Thrift… Have you ever imagined how to glue these together, in a micro-services architecture, and expose to the world? There are some common…","html":"<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fb5da5c014432c6f403808a14ba084c5/4d3f0/cover.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 720px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 66.75398384632176%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAME/8QAFgEBAQEAAAAAAAAAAAAAAAAAAwAE/9oADAMBAAIQAxAAAAHdC0Qs4fB//8QAGBABAAMBAAAAAAAAAAAAAAAAAAEEQUL/2gAIAQEAAQUC2yh1ZQ//xAAWEQADAAAAAAAAAAAAAAAAAAADEDH/2gAIAQMBAT8BNF//xAAWEQADAAAAAAAAAAAAAAAAAAADEDH/2gAIAQIBAT8BBF//xAAWEAEBAQAAAAAAAAAAAAAAAAACEAD/2gAIAQEABj8Cxpn/xAAZEAACAwEAAAAAAAAAAAAAAAAAARExcSH/2gAIAQEAAT8hVdL6OlbEoTrsvoSUf//aAAwDAQACAAMAAAAQYB//xAAWEQEBAQAAAAAAAAAAAAAAAAAAATH/2gAIAQMBAT8Q1Wv/xAAVEQEBAAAAAAAAAAAAAAAAAAAQMf/aAAgBAgEBPxCh/8QAHhAAAwAABwEAAAAAAAAAAAAAAAERIUFhcYGRwfD/2gAIAQEAAT8Qe7Y7XliuqVoOapUweQ8h9jHVqXB//9k='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Photo by Christian Stahl on Unsplash\"\n        title=\"\"\n        src=\"/static/fb5da5c014432c6f403808a14ba084c5/cfe7c/cover.jpg\"\n        srcset=\"/static/fb5da5c014432c6f403808a14ba084c5/f39eb/cover.jpg 180w,\n/static/fb5da5c014432c6f403808a14ba084c5/e1b9c/cover.jpg 360w,\n/static/fb5da5c014432c6f403808a14ba084c5/cfe7c/cover.jpg 720w,\n/static/fb5da5c014432c6f403808a14ba084c5/deb56/cover.jpg 1080w,\n/static/fb5da5c014432c6f403808a14ba084c5/cf22f/cover.jpg 1440w,\n/static/fb5da5c014432c6f403808a14ba084c5/54366/cover.jpg 2160w,\n/static/fb5da5c014432c6f403808a14ba084c5/4d3f0/cover.jpg 4581w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>GraphQL, REST, gRPC, Thrift… Have you ever imagined how to glue these together, in a micro-services architecture, and expose to the world? There are some common ways to do it, such as using Nginx or Kong, but an alternative way to do this is by using GraphQL in front of all services.</p>\n<h2>API Gateway pattern — a quick introduction</h2>\n<p>Considering service A and B, how a client would be able to request it’s data? The easiest and straight forward way would be to do a request to service A and another to B, each request pointing to different hosts.</p>\n<p>The problem is, as the number of services grow, it is quite laborous to keep up with this strategy (eg: too many services and requests to coordinate). To solve this, a proxy can be used, where the client will request to only one host instead of multiple, and this proxy service will orchestrate where this request should go, gluing all services in one place.</p>\n<p>API Gateways work as a proxy, but with some extras: caching, request transformation, throttling, security and others. GraphQL servers, been usually normal services, are highly configurable and can offer these as well.</p>\n<p>For more information on the api gateway pattern, give a look at <a href=\"https://www.nginx.com/blog/building-microservices-using-an-api-gateway/\">nginx micro-services article</a> and on this <a href=\"https://freecontent.manning.com/the-api-gateway-pattern/\">Chris Richardson article</a>.</p>\n<h2>Why GraphQL and not REST?</h2>\n<p>The gateway pattern is kinda well known, but why would a company opt by GraphQL instead of REST?</p>\n<h3>Schema validation and documentation</h3>\n<p>In GraphQL, differently from REST, a schema is always required, following <a href=\"https://graphql.org\">GraphQL Foundation</a> directives. This allows not only schema validation since day one, but documentation as well. Usually typed languages can generate type definitions using the graphql schema (example: <a href=\"https://github.com/dotansimha/graphql-code-generator\">typescript graphql-code-generator</a>)</p>\n<p>In theory, the same could be done in REST by using OpenAPI/Swagger (specially for documentation), but the code generation tools are not exactly the best and usually the schema validation do not work properly (or do not work at all).</p>\n<h3>One endpoint, multiple queries</h3>\n<p>GraphQL only exposes one endpoint. With this, instead of having N client requests to properly get an information, in GraphQL only one is needed, with the server orchestrating everything required to fulfill the request.</p>\n<p>The caveats with this are: how to deal with bulk queries and how to properly rate limit clients.</p>\n<ul>\n<li><a href=\"https://developer.github.com/v4/guides/resource-limitations/\">https://developer.github.com/v4/guides/resource-limitations/</a></li>\n</ul>\n<h3>Out-of-box standards</h3>\n<ul>\n<li>Sparse fieldset</li>\n<li>Versioning</li>\n</ul>\n<h3>Developer experience</h3>\n<h2>References</h2>\n<ul>\n<li>\n<p><a href=\"https://unsplash.com/photos/8S96OpxSlvg\">Photo by Christian Stahl on Unsplash</a></p>\n</li>\n<li>\n<p><a href=\"https://microservices.io/patterns/apigateway.html\">Pattern: API Gateway / Backend for Front-End</a></p>\n</li>\n<li>\n<p><a href=\"https://www.nginx.com/blog/building-microservices-using-an-api-gateway/\">Ngnix micro-services book chapter about API Gateway</a></p>\n</li>\n<li>\n<p><a href=\"https://freecontent.manning.com/the-api-gateway-pattern/\">Chris Richardson article about API Gateway</a></p>\n</li>\n<li>\n<p><a href=\"https://stoplight.io/blog/api-proxy-vs-api-gateway-c008c942a02d/\">API Proxy vs API Gateway</a></p>\n</li>\n<li>\n<p><a href=\"https://www.robinwieruch.de/why-graphql-advantages-disadvantages-alternatives/\">https://www.robinwieruch.de/why-graphql-advantages-disadvantages-alternatives/</a></p>\n</li>\n<li>\n<p><a href=\"https://medium.com/open-graphql/graphql-1-140fab436942\">https://medium.com/open-graphql/graphql-1-140fab436942</a></p>\n</li>\n<li>\n<p><a href=\"https://about.sourcegraph.com/graphql/graphql-at-massive-scale-graphql-as-the-glue-in-a-microservice-architecture\">https://about.sourcegraph.com/graphql/graphql-at-massive-scale-graphql-as-the-glue-in-a-microservice-architecture</a></p>\n</li>\n<li>\n<p><a href=\"https://webapplog.com/graphql/\">https://webapplog.com/graphql/</a></p>\n</li>\n<li>\n<p><a href=\"https://philsturgeon.uk/api/2017/01/26/graphql-vs-rest-caching/\">https://philsturgeon.uk/api/2017/01/26/graphql-vs-rest-caching/</a></p>\n</li>\n</ul>","frontmatter":{"title":"GraphQL as a Gateway","date":"April 03, 2019","cover":{"childImageSharp":{"fixed":{"width":1200,"height":801,"src":"/static/fb5da5c014432c6f403808a14ba084c5/935ac/cover.jpg","srcSet":"/static/fb5da5c014432c6f403808a14ba084c5/935ac/cover.jpg 1x,\n/static/fb5da5c014432c6f403808a14ba084c5/77668/cover.jpg 1.5x,\n/static/fb5da5c014432c6f403808a14ba084c5/5347b/cover.jpg 2x,\n/static/fb5da5c014432c6f403808a14ba084c5/6da74/cover.jpg 3x"}}}}}},"pageContext":{"slug":"/graphql-as-a-gateway/","previous":{"fields":{"slug":"/2019/mar/kubernetes-devops-productivity-hacks/"},"frontmatter":{"title":"Kubernetes devops productivity hacks"}},"next":null}}