{"data":{"site":{"siteMetadata":{"title":"Bruno Luiz Blog","author":"Bruno Luiz Silva"}},"markdownRemark":{"id":"ba1fa448-08a7-5f01-bcca-b5d8df403b76","excerpt":"Web APIs are everywhere nowadays, with REST been one of the most popular ways to distribute it. With recent technologies, there are improved ways to implement…","html":"<p>Web APIs are everywhere nowadays, with REST been one of the most popular ways to distribute it. With recent technologies, there are improved ways to implement it one of them been GRPC.\nWhy REST is popular and what are its pitfalls?\nCompanies used to write web-services in SOAP until REST got enough hype to be the next big thing, although the concept been around since 2000. It was like a fresh breeze for developers, with a lower learning curve, faster, simplified payload (usually JSON instead of XML), schema-less approach and no need for using specific clients/server generators.</p>\n<p>But after a certain time, some of its strengths shown to be some of its weaknesses. Not having a schema initially seemed a good idea, but developers eventually realised it is required. It can be useful for validation, documentation, contract agreement between teams and code-generation, to mention a few. Initiatives such as Swagger, RAML and most recently OpenAPI popped up to fill these gaps.</p>\n<p>Even though, a lack of an official standard to guide through decision processes usually ended up in analysis paralysis in big projects. Besides, code generation from most of these tools was not as good and ready to be used.</p>\n<p>JSON is the most preferred way to return data from REST APIs. It is an excellent choice for public services used by front-end applications and third-parties, but it is not well optimised for internal services communication. This is due to its overhead on transporting and decoding.</p>\n<p>Even with these issues, it doesn’t mean REST is a bad choice. It is by far the simplest way to implement an API, but there are known pitfalls due to its simplicity. This is where technologies such as GraphQL and GRPC are taking its place.\nEnters GRPC and Protocol Buffers\nGRPC is a modern Remote Procedure Call (RPC) framework built on top-off HTTP 2.0, using Protocol Buffers as its interface definition language  (IDL).</p>\n<p>The strict use of HTTP 2.0 enables developers to embrace some of its features, mainly streaming (client-side and server-side). For example:</p>\n<p>A client can send a bulk of messages through a stream, instead of sending one request each or one with all of them\nA client can send a request and receive a stream of responses, instead of waiting for the server to finish the processing and send a huge payload</p>\n<p>Protocol Buffers are a simpler and optimised way to define and serialise structured data. It can be used not only with GRPC but for other use cases, such as event modelling and data storage.</p>\n<p>Think Swagger (REST) or WSDL (SOAP), but lightweight due to the fact the payloads are binary, allowing faster serialisation and small footprint. As it is generated by tools such as protoc, it brings some benefits such as type-safety in compile-time and auto-completion in IDEs.</p>\n<p>In the snipped below, a GRPC service is defined using Protobuf. To generate a client and server in Golang for example, a simple protoc call with the protoc-gen-go plugin would do the job. Easy right?</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-protobuf line-numbers\"><code class=\"language-protobuf\">syntax <span class=\"token operator\">=</span> <span class=\"token string\">\"proto3\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">package</span> api<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Defines where your go package will be placed after compiled</span>\noption go_package <span class=\"token operator\">=</span> <span class=\"token string\">\"generated/api\"</span><span class=\"token punctuation\">;</span>\n\nservice Identity <span class=\"token punctuation\">{</span>\n  rpc GetUser <span class=\"token punctuation\">(</span>GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>GetUserResponse<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  rpc GetUsers <span class=\"token punctuation\">(</span>GetUsersRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>GetUsersResponse<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> User <span class=\"token punctuation\">{</span>\n  <span class=\"token primitive symbol\">string</span> user_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token primitive symbol\">string</span> name <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token primitive symbol\">bool</span> active <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> GetUserRequest <span class=\"token punctuation\">{</span>\n  <span class=\"token primitive symbol\">string</span> user_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> GetUserResponse <span class=\"token punctuation\">{</span>\n  User user <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> GetUsersRequest <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> GetUsersResponse <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Defines an array of users</span>\n  <span class=\"token builtin\">repeated</span> User users <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In any protobuf file, each field has a number associated with it. These are used as unique identifiers in the binarised message and should not be changed. If one of these gets deprecated, its identifiers can’t be re-used. Besides avoiding breaking changes, this allows a progressive evolution of the model, where developers don’t need to worry about fields been re-used and clashing with previous payloads.\nCreating a simple GRPC server and client in Golang</p>\n<p>Using the previous snippet, it is possible to create a simple GRPC server and client. The following tools need to be installed:\nProtocol buffers compiler, available at <a href=\"https://github.com/protocolbuffers/protobuf\">https://github.com/protocolbuffers/protobuf</a> — On MacOS, it is available as protobuf at brew\nGolang plugin, available at <a href=\"https://github.com/golang/protobuf\">https://github.com/golang/protobuf</a></p>\n<p>Create a new Golang project and place the proto definitions on its root. To generate GRPC server and client, something as simple as “protoc -I. —go<em>out=plugins=grpc:. api.proto”. The output will be placed at what was specified at the proto go</em>package option.</p>\n<p>To create a server, all methods defined by the proto need to implemented in a Golang struct.</p>","frontmatter":{"title":"GRPC: A powerful way to improve your APIs","date":"July 01, 2019","cover":null}}},"pageContext":{"slug":"/grpc/","previous":{"fields":{"slug":"/graphql-as-a-gateway/"},"frontmatter":{"title":"GraphQL feat API Gateway"}},"next":null}}