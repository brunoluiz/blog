{"data":{"site":{"siteMetadata":{"title":"Bruno Luiz Blog","author":"Bruno Luiz Silva"}},"markdownRemark":{"id":"ba1fa448-08a7-5f01-bcca-b5d8df403b76","excerpt":"Web APIs are everywhere, with REST been one of the most popular ways to distribute it. With recent technologies, there are improved ways to implement it, GRPCâ€¦","html":"<p>Web APIs are everywhere, with REST been one of the most popular ways to distribute it. With recent technologies, there are improved ways to implement it, GRPC been one of them.</p>\n<h1>Why REST is popular and what are its pitfalls?</h1>\n<p>Companies used to write web-services in SOAP until REST got enough hype to be the next big thing, although the concept been around since 2000. It was like a fresh breeze for developers. It had a low learning curve, simplified payload (usually JSON instead of XML), schema-less approach and no need for using specific clients/server generators.</p>\n<p>At a certain point, some of its strengths shown to be some of its weaknesses. Not having a schema initially seemed a good idea, but developers eventually realised it is required. It can be useful for validation, documentation, contract agreement between teams and code-generation, to mention a few. Initiatives such as Swagger, RAML and most recently OpenAPI popped up trying to fill these gaps.</p>\n<p>Even though, a lack of an official standard to guide through decision processes usually ended up in analysis paralysis in big projects. Besides, code generation from most of these tools was not as good and ready to be used (example: swagger-tools).</p>\n<p>JSON is the most preferred way to return data from REST APIs. It is an excellent choice for public services used by front-end applications and third-parties. Due to its overhead on transporting and decoding, it is not well optimised for internal services communication.</p>\n<p>Even with these issues, it doesnâ€™t mean REST is a bad choice. It is by far the simplest way to implement an API, but there are known pitfalls due to its simplicity. Technologies such as GraphQL, Thrift and GRPC come to fill these gaps.</p>\n<h1>Enters GRPC and Protocol Buffers</h1>\n<p>GRPC is a modern Remote Procedure Call (RPC) framework built on top-off HTTP 2.0, using Protocol Buffers as its interface definition language (IDL). These help it to be a low latency, high performance and scalable option to REST.</p>\n<p>The strict use of HTTP 2.0 enables developers to embrace some of its features, mainly streaming (client-side and server-side). For example:</p>\n<ul>\n<li>A client can send a bulk of messages through a stream, instead of sending one request each or one with all of them</li>\n<li>A client can send a request and receive a stream of responses, instead of waiting for the server to finish the processing and send a huge payload</li>\n</ul>\n<p>Protocol Buffers are a simpler and optimised way to define and serialise structured data. It can be used not only with GRPC but for other use cases, such as event modelling and data storage.</p>\n<p>Think Swagger (REST) or WSDL (SOAP), but lightweight due to the fact the payloads are binary, allowing faster serialisation and small footprint. Being generated by tools such as <code>protoc</code>, it brings some benefits such as type-safety in compile-time and auto-completion in IDEs.</p>\n<p>In the snippet below, a GRPC service is defined using Protobuf. Generating a client and server requires a simple <code>protoc</code> call. Easy right?</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-protobuf line-numbers\"><code class=\"language-protobuf\">syntax <span class=\"token operator\">=</span> <span class=\"token string\">\"proto3\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">package</span> api<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Defines where your go package will be placed after compiled</span>\noption go_package <span class=\"token operator\">=</span> <span class=\"token string\">\"generated/api\"</span><span class=\"token punctuation\">;</span>\n\nservice Identity <span class=\"token punctuation\">{</span>\n  rpc GetUser <span class=\"token punctuation\">(</span>GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>GetUserResponse<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  rpc GetUsers <span class=\"token punctuation\">(</span>GetUsersRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>GetUsersResponse<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> User <span class=\"token punctuation\">{</span>\n  <span class=\"token primitive symbol\">string</span> user_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token primitive symbol\">string</span> name <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token primitive symbol\">bool</span> active <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> GetUserRequest <span class=\"token punctuation\">{</span>\n  <span class=\"token primitive symbol\">string</span> user_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> GetUserResponse <span class=\"token punctuation\">{</span>\n  User user <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> GetUsersRequest <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> GetUsersResponse <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Defines an array of users</span>\n  <span class=\"token builtin\">repeated</span> User users <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In any protobuf file, each field has a number associated with it. These are unique identifiers in the binarised message and should not be changed. If one of these gets deprecated, they canâ€™t be re-used. It helps on avoiding breaking changes, allowing a progressive model evolution. Developers donâ€™t need to worry about fields been re-used, clashing with previous payloads, for example.</p>\n<h1>Creating a simple GRPC server and client in Golang</h1>\n<p>It is possible to create a simple GRPC server and client based on the previous protobuf definition. The following tools need to be installed:</p>\n<ul>\n<li><a href=\"https://github.com/protocolbuffers/protobuf\">Protocol buffers compiler</a></li>\n<li><a href=\"https://github.com/golang/protobuf\">Golang protoc plugin</a></li>\n</ul>\n<p>In a Golang project, running <code>protoc -I. --go\\_out=plugins=grpc:. api.proto</code> should generate both server and client. The <code>go\\_package</code> option in the protobuf specifies the generated code output path.</p>\n<p>To create a server, all methods defined by the proto need to implemented in a Golang struct. Peaking into the generated files, this is the interface generated from <code>service Identity</code>. An implementation fulfiling these methods will be enough to implement a server.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-go line-numbers\"><code class=\"language-go\"><span class=\"token keyword\">type</span> IdentityServer <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>GetUserRequest<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>GetUserResponse<span class=\"token punctuation\">,</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token function\">GetUsers</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>GetUsersRequest<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>GetUsersResponse<span class=\"token punctuation\">,</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>With its implementation, the following code will be enough to run it as a server.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-go line-numbers\"><code class=\"language-go\"><span class=\"token comment\">// Listen to a specific port</span>\nlis<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> net<span class=\"token punctuation\">.</span><span class=\"token function\">Listen</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tcp\"</span><span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">Getenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GRPC_ADDRESS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> err\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Create a new GRPC Server</span>\ns <span class=\"token operator\">:=</span> grpc<span class=\"token punctuation\">.</span><span class=\"token function\">NewServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Register our service implementation against the GRPC service</span>\napi<span class=\"token punctuation\">.</span><span class=\"token function\">RegisterIdentityServer</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> service<span class=\"token punctuation\">.</span><span class=\"token function\">NewServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Start serving</span>\n<span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">Serve</span><span class=\"token punctuation\">(</span>lis<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In the same generated code, there will be a client interface and constructor.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-go line-numbers\"><code class=\"language-go\"><span class=\"token keyword\">type</span> IdentityClient <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>ctx context<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">,</span> in <span class=\"token operator\">*</span>GetUserRequest<span class=\"token punctuation\">,</span> opts <span class=\"token operator\">...</span>grpc<span class=\"token punctuation\">.</span>CallOption<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>GetUserResponse<span class=\"token punctuation\">,</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token function\">GetUsers</span><span class=\"token punctuation\">(</span>ctx context<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">,</span> in <span class=\"token operator\">*</span>GetUsersRequest<span class=\"token punctuation\">,</span> opts <span class=\"token operator\">...</span>grpc<span class=\"token punctuation\">.</span>CallOption<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>GetUsersResponse<span class=\"token punctuation\">,</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The service needs to dial the GRPC server and then build a client instance using this connection. With the client instance, the service will be able to make GRPC calls.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-go line-numbers\"><code class=\"language-go\"><span class=\"token comment\">// Set up a connection to the server.</span>\nconn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> grpc<span class=\"token punctuation\">.</span><span class=\"token function\">Dial</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span><span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"grpc-address\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> grpc<span class=\"token punctuation\">.</span><span class=\"token function\">WithInsecure</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> grpc<span class=\"token punctuation\">.</span><span class=\"token function\">WithBlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> err\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">defer</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Create GRPC Client</span>\nclient <span class=\"token operator\">:=</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">NewIdentityClient</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Cancels context after 1 second (timeout)</span>\nctx<span class=\"token punctuation\">,</span> cancel <span class=\"token operator\">:=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">WithTimeout</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span><span class=\"token function\">Background</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">defer</span> <span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Call GRPC Service</span>\nu<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>api<span class=\"token punctuation\">.</span>GetUserRequest<span class=\"token punctuation\">{</span>\n  UserId<span class=\"token punctuation\">:</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">Args</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> errors<span class=\"token punctuation\">.</span><span class=\"token function\">Wrap</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> <span class=\"token string\">\"issue on retrieving users\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nlogrus<span class=\"token punctuation\">.</span><span class=\"token function\">Infof</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"User: %s\"</span><span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">.</span>User<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Of course, this is the bare minimum set-up for a client and server. Interceptors can be added on both client and server, adding custom hooks to any method call and applying some transformations. UnaryInterceptors deal with requests which expect a single response back. StreamInterceptors applies to any streamed response or request.</p>\n<p>Interceptors for authorisation, validation, monitoring and others can be found at <a href=\"https://github.com/grpc-ecosystem/go-grpc-middleware\">go-grpc-middleware</a>. Remember, donâ€™t repeat yourself ðŸ˜‰</p>\n<h1>GRPC and REST together: What is this<strong>, a crossover episode?</strong></h1>\n<p>As previously mentioned, REST simplicity and low learning curve are some of its selling points. It allows quick testing, without the need to set-up a client binary â€” who never did a quick <code>curl</code> to check some API? Besides, it is easier for non-developers to play with it. As it is web services <em>lingua franca,</em> it might be required for third-party or front-end integrations as well.</p>\n<p>GRPC might be more efficient and better in some cases, but it is not as straightforward to use as REST. What if both could be used together, within the same service? That is where GRPC Gateway shines, integrating both worlds in one.</p>\n<p>Through annotations, a service can define which methods will be exposed as REST. Using the previous GRPC protobuf:</p>\n<p><strong>&#x3C; add snippet here ></strong></p>\n<p>With annotations in place, protoc needs to be changed to use the grpc-gateway plugin.</p>\n<p><strong>&#x3C; add snippet here ></strong></p>\n<p>After running <code>protoc</code>, the reverse-proxy code will be available for use. Is just a matter of creating an HTTP server for it. The following implementation is running it in a separate server.</p>\n<p><strong>&#x3C; add snippet here ></strong></p>\n<p><em>It can be run on the same server as GRPC, requiring some goroutines for it.</em></p>\n<p>Any REST client should be able to connect and request data to the exposed endpoints. Server up, this is curlâ€™s output:</p>\n<p><strong>&#x3C; add snippet here ></strong></p>\n<p>Magic, isnâ€™t it? Having this REST set-up might put a smile on some faces. The service can be migrated to GRPC for internal usage, keeping compatibility with REST clients â€” third-parties, non-techies and front-end applications.</p>\n<h1>Fantastic debugging tools and where to find them</h1>\n<p>Sooner or later, a quick peek into the service will be required, for debugging or scriptting purposes. In REST this can be done through tools such as curl, Insomnia or Postman. In GRPC, a different set of tools is required.</p>\n<p>For the Graphical Interface lovers, the most popular one is <a href=\"https://github.com/uw-labs/bloomrpc\">BloomRPC</a>. It only requires the proto files to be loaded and then it works similarly to any other REST client.</p>\n<p><strong>&#x3C; add gif ></strong></p>\n<p>For mouse avoiders â€” or terminal lovers ðŸ˜… â€” there are two quite useful tools. <a href=\"https://github.com/fullstorydev/grpcurl\">GRPCurl</a> is an awesome CLI tool, resembling curl and allow easy GRPC automation and scripting. A simple example of its usage follows:</p>\n<p><code>grpcurl --plaintext --proto api/api.proto localhost:5000 api.Identity/GetUsers</code></p>\n<p><em>By default, it tries to connect through TLS. Hence why the plaintext parameter.</em></p>\n<p><a href=\"https://github.com/ktr0731/evans\">Evans</a> goes a little bit further, as it has a REPL mode as well, allowing easier resource inspections (my favourite).</p>\n<p><strong>&#x3C; add gif ></strong></p>\n<p>These tools, GUI or not, are quite useful while testing and inspecting GRPC services. Try them and find the one which fits your needs better ðŸ˜‰</p>\n<h1>Experience and Summary</h1>\n<p>On my actual workplace, GRPC has been proved quite useful for connecting services, especially internal ones. Protocol Buffers came to be our main IDL when defining contracts for APIs and Stream Events. Due to these contracts, communicating implementations and changes are easier.</p>\n<p>Implementing service clients and servers had been easier and faster. The most common issue is due to include paths errors, which sometimes get messy. But this is more due to our learnings around it than the technology itself.</p>\n<p>For Golang, it proved to work quite well in most cases, with good community support. But, <code>protoc</code> can generate code to other languages as well, such as NodeJS and Java. Although, in our NodeJS services, we felt GRPC support is still behind Golang.</p>\n<p>In general, GRPC has been a good choice for our services. Hopefully, it will be good for your team as well.</p>","frontmatter":{"title":"GRPC: A powerful way to improve your APIs","date":"July 01, 2019","cover":null}}},"pageContext":{"slug":"/grpc/","previous":{"fields":{"slug":"/2019/mar/kubernetes-devops-productivity-hacks/"},"frontmatter":{"title":"Kubernetes devops productivity hacks"}},"next":{"fields":{"slug":"/graphql-as-a-gateway/"},"frontmatter":{"title":"GraphQL feat API Gateway"}}}}